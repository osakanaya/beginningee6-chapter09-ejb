package org.beginningee6.book.chapter09.ejb.ex01;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.beginningee6.book.chapter09.jpa.ex01.Item01;

/**
 * 
 * ●概要
 * 
 * コンテナ管理トランザクション（CMT）によりトランザクションを制御する
 * ように実装されたステートレス・セッションBeanのサンプル。
 * 
 * また、このサンプルでは、あるEJBのメソッドが別のEJBのメソッドを呼び出し、
 * かつ、どちらのメソッドもデータベースに代表されるトランザクションリソースを
 * 更新するような状況において、特にトランザクションのACID特性のうち、
 * 原子性（Atomicity）をどのように確保するかを示している。
 * 
 * ●このサンプルで示すトランザクション処理の状況
 * 
 * このサンプルでは、ItemEJBとInventoryEJBという2つのEJBがあり、
 * それぞれのメソッドでは、以下のような処理を行っている。
 * 
 * １．２つのEJBメソッドから行ったデータベース更新をともにコミットする例
 * 
 * ・ItemEJB.createItem()：
 * 　Item01エンティティを永続化する。永続化が終了すると、IventoryEJB
 * 　のaddItem()メソッドを呼び出し、Item01エンティティの在庫数量を
 * 　ひとつ増やす。
 * ・InventoryEJB.addItem()：
 * 　Item01エンティティの在庫数量をひとつ増やし、その変更をデータベース
 * 　に反映する。
 * 
 * ２．2つのEJBメソッドから行ったデータベース更新をともにロールバックする例
 * 
 * ・ItemEJB.createItemFail()：
 * 　Item01エンティティを永続化する。永続化が終了すると、IventoryEJB
 * 　のaddItem()メソッドを呼び出し、Item01エンティティの在庫数量を
 * 　ひとつ増やす。
 * ・InventoryEJB.addItemFail()：
 * 　Item01エンティティの在庫数量をひとつ増やし、その後、明示的に
 * 　トランザクションをロールバックするようにマークする。
 * 
 * ●EJBメソッドから別EJBのメソッドを呼び出す方法
 * 
 * あるEJBから別のEJBのメソッド呼び出しを行う場合は、呼び出されるEJBへの
 * 参照（この例ではIventoryEJB）を保持するフィールドを宣言し、この宣言に
 * ＠EJBアノテーションを付加する。
 * 
 * ●EJBメソッド実行時におけるトランザクション制御の方法について
 * 
 * トランザクションの開始およびコミット／ロールバックといった、EJBメソッド実行時の
 * トランザクション制御については、以下の2つのいずれかを選択することができ、
 * Beanのクラス宣言に＠TransactionManagementアノテーションを付与することにより
 * 宣言できる。
 * 
 * １．コンテナ管理トランザクションによるトランザクション制御
 * 
 * 　　後述するトランザクション属性によってトランザクションの開始がEJBコンテナに
 * 　　よって自動的に制御される。
 * 　　トランザクションのコミットおよびロールバックについても基本的に自動で制御
 * 　　される。
 * 
 * ２．Bean管理トランザクションによるトランザクション制御
 * 
 * 　　EJB開発者がEJBメソッドの中で明示的にトランザクションの開始やコミット／
 * 　　ロールバックを行うコードを記述する必要がある。
 * 
 * このサンプルでは、ItemEJBもInventoryEJBもコンテナ管理トランザクションによる
 * トランザクション制御を行うように実装されているEJBであるため、プログラム中で
 * 明示的にトランザクションの開始やコミットを行うステートメントを記述する必要は
 * ない。
 * 　
 * トランザクションのロールバックについても、システムエラーを表現する非チェック
 * 例外がスローされた場合は、自動的にトランザクションがロールバックされるように
 * なっている。
 * 
 * ただし、アプリケーションロジックの必要性からトランザクションをロールバック
 * する必要がある場合は、SessionContext.setRollbackOnly()メソッドを実行して
 * トランザクションをロールバックするようにEJBコンテナに通知する。
 * 
 * setRollbackOnly()はあくまでもEJBコンテナへの通知のみでロールバックは
 * 行われない。ロールバックは、トランザクション境界の外に出ようとする
 * メソッド完了時にEJBコンテナによって自動的に処理される。
 * 
 * ●EJBメソッドのトランザクション属性について
 * 
 * EJBとして宣言されるクラスのメソッドには、メソッド実行の開始時の
 * トランザクションスコープを制御するためのトランザクション属性を
 * 設定することができる。このトランザクション属性は、＠TransactionAttribute
 * アノテーションを用いて設定する。
 * 
 * このサンプルでは、上記4つのすべてのメソッドで＠TransactionAttribute
 * アノテーションにより明示的にトランザクション属性を設定していないが、
 * この場合は、デフォルトのトランザクション属性としてREQUIREDが暗黙的に適用される。
 * 
 * このREQUIREDというトランザクション属性は、トランザクションスコープに関して
 * 以下のような影響を及ぼす。
 * 
 * ・トランザクションを開始していないクライアントがこのメソッドを実行した場合、
 * 　メソッド開始時にトランザクションがEJBコンテナによって自動的に開始され、
 * 　メソッド終了時にトランザクションのコミットまたはロールバックが自動的に
 * 　行われる。
 * 
 * ・トランザクションを開始してまだそのトランザクションをコミットまたは
 * 　ロールバックしていないクライアントがこのメソッドを実行した場合、
 * 　そのメソッドでデータベースなどのトランザクションリソースに加えられた
 * 　変更は、クライアントが開始したトランザクションの一部として扱われる。
 * 　従って、メソッドが終了してもトランザクションはコミットまたはロールバック
 * 　されることなく、コミット／ロールバックの判断はEJBを呼び出したクライアント
 * 　にゆだねられる。
 * 
 * 【２つのEJBメソッドから行ったデータベース更新をともにコミットする例】
 * 
 * この例で、トランザクションを開始していないクライアント（＝すなわち
 * JUnitのテストコード）がItemEJB.createItem()メソッドを実行すると、
 * トランザクションは、以下のように制御される。
 * 
 * １．クライアントがトランザクションを開始していないため、ItemEJB.createItem()
 * 　　のメソッドを実行する前にトランザクションが開始される。
 * ２．Item01エンティティを永続化する。
 * ３．ItemEJB.createItem()メソッドからInventoryEJB.addItem()メソッドを呼び出す。
 * ４．InventoryEJB.addItem()メソッドから見たクライアントはItemEJB.createItem()
 * 　　メソッドであり、このメソッドはすでにトランザクションを開始しているため、
 * 　　InventoryEJB.addItem()メソッドの開始時にはトランザクションの開始が
 * 　　行われない。
 * ５．Item01エンティティを更新する。この更新は、上記１．で開始したトランザクション
 * 　　の一部として扱われる。
 * ６．上記４．と同様の理由で、InventoryEJB.addItem()メソッドの終了時には
 * 　　トランザクションのコミットもロールバックも行われない。
 * ７．ItemEJB.createItem()メソッドの処理を終了する。トランザクションを開始していない
 * 　　クライアントに制御を戻すことになるため、ここでトランザクションのコミット
 * 　　が行われる。この時点で、上記２．と５．の永続化と更新がデータベースにコミット
 * 　　される。
 * 
 * 【２つのEJBメソッドから行ったデータベース更新をともにロールバックする例】
 * 
 * この例で、トランザクションを開始していないクライアント（＝すなわち
 * JUnitのテストコード）がItemEJB.createItemFail()メソッドを実行すると、
 * トランザクションは、以下のように制御される。
 * 
 * １．クライアントがトランザクションを開始していないため、ItemEJB.createItemFail()
 * 　　のメソッドを実行する前にトランザクションが開始される。
 * ２．Item01エンティティを永続化する。
 * ３．ItemEJB.createItemFail()メソッドからInventoryEJB.addItemFail()メソッドを呼び出す。
 * ４．InventoryEJB.addItemFail()メソッドから見たクライアントはItemEJB.createItemFail()
 * 　　メソッドであり、このメソッドはすでにトランザクションを開始しているため、
 * 　　InventoryEJB.addItemFail()メソッドの開始時にはトランザクションの開始が
 * 　　行われない。
 * ５．Item01Failエンティティを更新する。この更新は、上記１．で開始したトランザクション
 * 　　の一部として扱われる。
 * ６．SessionContext.setRollbackOnly()メソッドを実行し、トランザクションをロールバック
 * 　　にマークする。ここでは、マークするだけで、ロールバックはまだ行われない。
 * ７．上記４．と同様の理由で、InventoryEJB.addItemFail()メソッドの終了時には
 * 　　トランザクションのコミットもロールバックも行われない。
 * ８．ItemEJB.createItemFail()メソッドの処理を終了する。トランザクションを開始していない
 * 　　クライアントに制御を戻すことになるため、ここでトランザクションのロールバック
 * 　　が行われる。この時点で、上記２．と５．の永続化と更新がロールバックされ、
 * 　　結果としてデータベースには何も変更が行われないことになる。
 * 
 */
@Stateless
// EJBコンテナがEJBメソッド実行時のトランザクション制御を行うように設定
// ＠TransactionManagementアノテーションを付与しない場合は、コンテナ管理
// トランザクションがデフォルトとなる
//@TransactionManagement(TransactionManagementType.CONTAINER)
public class ItemEJB {

	// エンティティの永続化を必要とするため、Entity Managerを注入
	@PersistenceContext(unitName = "Chapter09ProductionPU")
	private EntityManager em;

	// 他のEJBメソッドを呼び出す場合は、＠EJBアノテーションにより
	// EJBへの参照（ローカルインタフェースで使用するEJB、リモート
	// インタフェースで使用するEJB、インタフェース無しで使用するEJB
	// のいずれか）を注入する
	@EJB
	private InventoryEJB inventoryEJB;

	/**
	 * ２つのEJBメソッドから行ったデータベース更新をともにコミットする例。
	 * 
	 * @param item 永続化と更新を行うItem01エンティティ
	 * @return 永続化と更新が行われたItem01エンティティ
	 */
	// EJBメソッドのトランザクション属性を設定
	// ＠TransactionAttributeアノテーションを付与しない場合、
	// デフォルトのREQUIREDが設定される
//	@TransactionAttribute(TransactionAttributeType.REQUIRED)
    public Item01 createItem(Item01 item) {
    	// トランザクションを開始していないクライアントから
    	// 実行した場合、メソッド開始時にトランザクションを
    	// 自動的に開始
    	
    	// Item01エンティティを永続化
        em.persist(item);
        
        // Item01エンティティを更新
        // InventoryEJB.addItem()のトランザクション属性も
        // REQUIREDであるため、createItem()で開始したトランザクション
        // がaddItem()へ引き継がれる
        inventoryEJB.addItem(item);

        return item;
        
        // メソッド完了時に自動的にコミット
    }
    
    /**
	 * ２つのEJBメソッドから行ったデータベース更新をともにロールバックする例。
	 * 
	 * @param item 永続化と更新を行うItem01エンティティ
     */
	// EJBメソッドのトランザクション属性を設定
	// ＠TransactionAttributeアノテーションを付与しない場合、
	// デフォルトのREQUIREDが設定される
//	@TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void createItemFail(Item01 item) {
    	// トランザクションを開始していないクライアントから
    	// 実行した場合、メソッド開始時にトランザクションを
    	// 自動的に開始
    	
    	// Item01エンティティを永続化
    	em.persist(item);
    	
        // Item01エンティティを更新
        // InventoryEJB.addItemFail()のトランザクション属性も
        // REQUIREDであるため、createItemFail()で開始したトランザクション
        // がaddItemFail()へ引き継がれる
    	//
    	// addItemFail()でトランザクションがロールバックにマークされる
    	inventoryEJB.addItemFail(item);
    	
        // メソッド完了時に自動的にロールバック
    }
}
